<?xml version="1.0" ?>

<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/dtd/xml/4.5/docbookx.dtd">


<article status="draft" class="specification"> <title>Discrete Events System framework (multiagents based) ver. 5. Design.</title>

    <articleinfo>
	<author><personname><firstname>Yuri</firstname><surname>Borisov</surname></personname>
	    <email>yuri.borisov.v@gmail.com</email></author> 

	<releaseinfo>Ver.0.01 at 21-Feb-2025</releaseinfo>

	<abstract>
	    <simpara>This document collects software desing for Discrete Events System (DES) framework ver 5.</simpara>
	</abstract>

	<revhistory>
	    <revision> <revnumber>0.01</revnumber> <date>05-Mar-2020</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Initial version</revremark> </revision>
	</revhistory>

    </articleinfo>

    <bibliolist>
	<title>References</title>

	<biblioentry id="ref_incr_mut"> <abbrev>INCR_MUT</abbrev>
	    <productname><ulink url="../../../fap-doc/doc_incr_syst_creation/index.html "/></productname>
	    <title>Y.Borisov. Using incremental mutation process for systems modeling</title> </biblioentry>

	<biblioentry id="ref_rfc_3986"> <abbrev>RFC_3986_URI</abbrev>
	    <productname><ulink url="httpss://www.ietf.org/rfc/rfc3986.txt"/></productname>
	    <title>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</title> </biblioentry>

	<biblioentry id="ref_ss_cof"> <abbrev>SS_COF</abbrev>
	    <productname>Local copy <ulink url="files://home/yborisov/Documents/Compilators/Konstruirovanie_Kompilyatorov.pdf"/></productname>
	    <title>Sergey Swerdlov. Creating of compilators.</title> </biblioentry>
    </bibliolist>

    <glossary> <title>Glossary</title> 
	<glossentry id="gls_adp"><glossterm>ADP</glossterm> <acronym>ADP</acronym>
	    <glossdef> <para>
		Agents DES adaPtorThe agent dedicated to adapt target agent interfaces to DES. Ref
		    <ulink url="../../../grayb/doc/design/index.html#ds_dmm_adp"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_asr"><glossterm>ASR</glossterm> <acronym>ASR</acronym>
	    <glossdef> <para>
		DES. Activation on system reconfiguration. The feature where DES is activated on the structure
			reconfiguration. Ref
		    <xref linkend="ds_asr"/> </para></glossdef>
	</glossentry>


	<glossentry id="gls_ascl"><glossterm>ASCL</glossterm>
	    <glossdef> <para>
		Agents specific chromo languge. The approach that allows specific mutations and even chromo syntax for some agents. Ref
		    <xref linkend="ds_ascl"/> for details.</para></glossdef>
	</glossentry>

	<glossentry id="gls_cac"><glossterm>CAC</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>
		Change As Chromo but not mutation.  Approach of representing model agents change. Ref
		    <xref linkend="ds_adcm"/> for details.  Ref
		    <xref linkend="gls_cam"/> for alternative approach. </para></glossdef>
	</glossentry>

	<glossentry id="gls_cam"><glossterm>CAM</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>
		Change As Mutation but not chromo. Approach of representing model agents change. Ref
		    <xref linkend="ds_adcm"/> for details.  Ref
		    <xref linkend="gls_cac"/> for alternative approach. </para></glossdef>
	</glossentry>

	<glossentry id="gls_cp"><glossterm>CP</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>Connection Point. Element that is used as endpoint of connections between systems. </para></glossdef>
	</glossentry>

	<glossentry id="gls_chromo2"><glossterm>CHROMO2</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>
		Enhanced version of chromo language. Uses specific syntac instead of xml-based in the initial version. Ref
		    <ulink url="../../../grayb/doc/design/index.html#ds_chr2"/> for details. </para></glossdef>
	</glossentry>

	<glossentry id="gls_daa"><glossterm>DAA</glossterm> <acronym>DAA</acronym>
	    <glossdef> <para>
		Distributed Agents Approach.  Approach of multi-agent system that assumes that the modes is distributed among several environments that 
			can be running on undependent executable enviromnents. Ref
		    <xref linkend="ds_daa"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_dce"><glossterm>DCE</glossterm> <acronym>DCE</acronym>
	    <glossdef> <para>
			Dedicated Content Element of native hier.  Approach of content support based on dedicated elements of native hier. Ref
		    <xref linkend="ds_dce"/> for desing details </para></glossdef>
	</glossentry>

	<glossentry id="gls_dcs"><glossterm>DCS</glossterm> <acronym>DCS</acronym>
	    <glossdef> <para>
			DES Control of System, the mechanism of managing some subsystem by DES. 
		    <xref linkend="ds_dcs"/> for desing details </para></glossdef>
	</glossentry>

	<glossentry id="gls_dctx"><glossterm>DCTX</glossterm> <acronym>DCTX</acronym>
	    <glossdef> <para>
                DES context, the mechanism of propagating data between system and its subsystem. 
                Widely used in complex systems to simplify the system structure.
		    </para></glossdef>
	</glossentry>



	<glossentry id="gls_ssp"><glossterm>SSP</glossterm>
	    <glossdef><para>
		DES Service Point. Mechanism the system provides to the "client" to update clents state depending on system context.
		    <xref linkend="ds_ssp"/> for desing details </para></glossdef>
	</glossentry>

	<glossentry id="gls_deds"><glossterm>DEDS</glossterm> <acronym>DEDS</acronym>
	    <glossdef> <para>
		Discrete Event Dynamic System,  a discrete-state, event-driven system of which the state evolution depends entirely
		on the occurrence of asynchronous discrete events over time. Although similar to continuous-variable dynamic systems (CVDS),
		DEDS consists solely of discrete state spaces and event-driven state transition mechanisms.  Ref
		    <ulink url="https://en.wikipedia.org/wiki/Discrete_event_dynamic_system"/></para>
		<glossseealso otherterm="gls_des"/> </glossdef>
	</glossentry>

	<glossentry id="gls_des"><glossterm>DES</glossterm> <acronym>DES</acronym>
	    <glossdef> <para>
		Discrete-Event Simulation - model of the operation of a system as a discrete sequence of events in time.
		Each event occurs at a particular instant in time and marks a change of state in the system. Ref
		    <ulink url="https://en.wikipedia.org/wiki/Discrete-event_simulation"/></para> <glossseealso otherterm="gls_deds"/>
		<para>Also this abbreviation is designates Discrete Event System, the implementation of discrete-event simulation.</para>
	    </glossdef>
	</glossentry>

	<glossentry id="gls_desas"><glossterm>DESAS</glossterm> <acronym>DESAS</acronym>
	    <glossdef> <para>
		Discrete Event System Active Subsystem, the part of discrete-event system that is implemented as
			autonomous sub-system. Ref <xref linkend="ds_desas"/></para> for design.</glossdef>
	    </glossentry>

	    <glossentry id="gls_dhc"><glossterm>DHC</glossterm> <acronym>DHC</acronym>
	    <glossdef> <para>Direct Hierarchical Chromosome</para> <para>
		Approach of multi-agent system definition that describes the model's structure directly. 
		Ref <xref linkend="ds_smc"/> for discussion regarding chromo desing approaches.
		    Ref <xref linkend="gls_osm"/> for anoter design approach.</para></glossdef> </glossentry>

	<glossentry id="gls_dmc"><glossterm>DMC</glossterm> <acronym>DHC</acronym>
	    <glossdef> <para>Dependent Mutations Chromosome</para> <para>
		Chromo definition approach when the mutation can have other mutaions (of node type) as the operands.
		This approach helps defining the model with anonymous nodes that is especially effective for <xref linkend="gls_des"/> models.
		    Ref <ulink url="../../../grayb/doc/design/index.html#gls_dmc"/> for original glossary. </para></glossdef> </glossentry>

	<glossentry id="gls_ddmc"><glossterm>DDMC</glossterm> <acronym>DHC</acronym>
	    <glossdef> <para>
		Direct Dependent Mutations Chromosome structure.
		Chromo structure that directly aligned to
		    <xref linkend="gls_dmc"/>.
			This approach allows to have single unified chromo representation.  Ref
		    <ulink url="ds_cli_ddmc"/> for details.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_ccn"><glossterm>CCN</glossterm> <acronym>CCN</acronym>
	    <glossdef> <para>
		Compact (and customized) Chromo Notation, approach that focus on having compact notation of model chromo.
		This allows effectivelly creating the model via 'manually' creating chromo of it. Another solution
		is Native Chromo Notation, ref
		    <xref linkend="gls_ncn"/>. </para></glossdef> </glossentry>

	<glossentry id="gls_clm"><glossterm>CLM</glossterm> <acronym>CLM</acronym>
	    <glossdef> <para>Command Line Monitor application <ulink url="../../../grayb/doc/design/index.html#gls_clm"/> for original glossary </para></glossdef> </glossentry>

	<glossentry id="gls_cmt"><glossterm>CMT</glossterm> <acronym>CMT</acronym>
	    <glossdef> <para>Combined Mutation Target.  The approach of specifying target in mutation spec when mutation target and change targets are
		spedified separately. With this approach the target specified with two mutation attribute, ref also <xref linkend="gls_umt"/> for
		    alternative approach.</para></glossdef> </glossentry>

	<glossentry id="gls_cpa"><glossterm>CPA</glossterm> <acronym>CPA</acronym>
	    <glossdef> <para>Connecting Proxy Agent.
		The approach of agents design where dedicated embedded agents play the role of 
		connection points of agent, i.e. doing all connecting relative work instead of agent.
		In contrast of <xref linkend="gls_pia"/> connecting proxy agent provides interface
		    resolution mechanism for the client, so the mechanism is distributed between multiple
		    connecting agents in the model.  </para></glossdef> </glossentry>

	<glossentry id="gls_dmm"><glossterm>DMM</glossterm> <acronym>DMM</acronym>
	    <glossdef> <para>
		DES Managing of Model.  The approach of using DES to manage the generic multi-agent model.
		With this approach it is not needed to have some external native model managing entity, this managing entity
		is implemented as managing DES model, ref also
		    <xref linkend="ds_dmm"/> for details.</para></glossdef> </glossentry>

	<glossentry id="gls_dri"><glossterm>DRI</glossterm> <acronym>DRI</acronym>
	    <glossdef> <para>Direct Resolution of Interfaces</para> <para>
		Design approach of resolving interfaces by agents. With that approach agent gets the iface provided by connpoint. 
		This approach is the alternative of
		    <xref linkend="gls_irm"/>.  Ref
		    <xref linkend="ds_dri"/> for details. </para></glossdef> </glossentry>


	<glossentry id="gls_eosm"><glossterm>EOSM</glossterm> <acronym>OSM</acronym>
	    <glossdef> <para>
		Extended Original Sequence of Mutations chromo language approach- 
		The approach of models creation where the same mutation order is
		used for model creation as on construction phase. This approach extends
		    <xref linkend="gls_osm"/> in that, enables segments in mutation output chromo. Initial
		    <xref linkend="gls_osm"/> solution just transormed hierarchical input chromo to flat structre (without segments) </para></glossdef>
	</glossentry>

	<glossentry id="gls_fap2"><glossterm>FAP2</glossterm> <acronym>FAP2</acronym>
	    <glossdef> <para>
		Discrete Events System (DES) framework ver. 2 aka "grayb". Ref
		    <ulink url="../../../grayb/doc/design/index.html"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_irm"><glossterm>IRM</glossterm>
	    <glossdef> <para>
		Interface resolution mechanism. Ref for initial design
		    <ulink url="../../../grayb/doc/design/index.html#ds_ifcache"/>
			Alternative design approach is
		    <xref linkend="gls_dri"/>
	</para></glossdef> </glossentry>

	<glossentry id="gls_irmc"><glossterm>IRMC</glossterm>
	    <glossdef> <para>
		Interface resolution mechanism with caching result. This solution reduces access to resolved ifaces, to increase
		the model performance.  Ref
		    <xref linkend="ds_irm_cr"/> for details.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_lsc"><glossterm>LSC</glossterm>
	    <glossdef> <para>
		Layered System Control. Controlling of DES specific approach where controlling part is isolated from controlled in separate "layer".
		Ref
		    <xref linkend="ds_dcs_sl"/> for details.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_mso"><glossterm>MSO</glossterm> <acronym>MSO</acronym>
	    <glossdef> <para>
			Managed Subsystem Owned, approach of <xref linkend="gls_lsc"/>
			    where Owned subsystem is owned by managing subsystem. Ref
		    <xref linkend="ds_dcs_sl_hil_s1"/>.
	</para></glossdef> </glossentry>

	<glossentry id="gls_ncn"><glossterm>NCN</glossterm> <acronym>NCN</acronym>
	    <glossdef> <para>
		Native Chromo Notation, approach that focus on very simple chromo notation, like
		assembler. It is 'universal', less readable and more suitable for creating model with IDE. Another solution
		is Compact Chromo Notation, ref
		    <xref linkend="gls_ccn"/>.
	</para></glossdef> </glossentry>

	<glossentry id="gls_osm"><glossterm>OSM</glossterm> <acronym>OSM</acronym>
	    <glossdef> <para>
		Original Sequence of Mutations - 
		The approach of models creation where the same mutation order is
		used for model creation as on construction phase, ref
		    <ulink url="../../../grayb/doc/design/index.html#ds_mut_osm"/>. Ref
		    <xref linkend="gls_dhc"/> for another approach.  Ref also
		    <xref linkend="gls_eosm"/> for extended solutions.
	</para></glossdef> </glossentry>

	<glossentry id="gls_odb"><glossterm>ODB</glossterm> <acronym>ODB</acronym>
	    <glossdef> <para>
		An object database or object-oriented database is a database management system in which information is represented
		in the form of objects as used in object-oriented programming.
		    <ulink url="https://en.wikipedia.org/wiki/Object_database"/> and
		    <ulink url="https://www.service-architecture.com/articles/object-oriented-databases/"/>.
	</para></glossdef> </glossentry>


	<glossentry id="gls_orm"><glossterm>ORM</glossterm> <acronym>ORM</acronym>
	    <glossdef> <para>
		Objectâ€“relational mapping (ORM, O/RM, and O/R mapping tool) in computer science is a programming technique
		for converting data between a relational database and the heap of an object-oriented programming language.
		This creates, in effect, a virtual object database that can be used from within the programming language.
		    <ulink url="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping"/> and
		    <ulink url="https://www.service-architecture.com/articles/object-oriented-databases/object-relational-mapping.html"/>.
	</para></glossdef> </glossentry>

	<glossentry id="gls_mae"><glossterm>MAE</glossterm>
	    <glossdef> <para>
		Using monodilic agent instead of embedded.  Optimization approach, where monolitic native agents instead of constructed agents.
		    <xref linkend="ds_mae"/> </para></glossdef>
	</glossentry>

	<glossentry id="gls_pia"><glossterm>PIA</glossterm> <acronym>PIA</acronym>
	    <glossdef> <para>
		Properties Instead of embedded auxiliary Agents
		The approach of agents design where properties are using instead of auxiliary agents
		in order to minimize the agents number, ref
		    <xref linkend="ds_pia"/>. Ref <xref linkend="gls_cpa"/> for another connecting solution. </para></glossdef>
	</glossentry>

	<glossentry id="gls_csl"><glossterm>CSL</glossterm> <acronym>CSL</acronym>
	    <glossdef> <para>
		Connecting Same Layer vertices -
		Model creation policy of binding vertexes. According to this policy the only same layer
		vertexes can be connected. The owner of the layer is respondible to verify the policy.
		    <xref linkend="ds_conn_cwdl"/>.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_scc"><glossterm>SCC</glossterm> <acronym>SCC</acronym>
	    <glossdef> <para>
		State with Combined Chains. DES state design where data and observing chains are same.
		    <xref linkend="ds_mae_scc"/>. Ref <xref linkend="gls_ssc"/> for another design solution.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_sdc"><glossterm>SDC</glossterm> <acronym>SDC</acronym>
	    <glossdef> <para>
		System DES controller. The mechanism of system structure update controlled by DES where the controlling DES "accesses"
		to managed system structure via a number of specialized systems performing certain mutation. 
		     Ref <xref linkend="gls_adp"/> for another design solution.</para></glossdef>
	</glossentry>

	<glossentry id="gls_sdo"><glossterm>SDO</glossterm> <acronym>SDO</acronym>
	    <glossdef> <para>
		System DES observer. The mechanism of system structure observing compatible with DES.
		     Ref <xref linkend="ds_dcs_sdo"/> for details.</para></glossdef>
	</glossentry>

	<glossentry id="gls_slc"><glossterm>SLC</glossterm> <acronym>SCC</acronym>
	    <glossdef> <para>
		Sockets Loopback Connections. Socket design approach when loopback connections are supported
		    <xref linkend="ds_ifcache_slc"/>. </para></glossdef>
	</glossentry>

	<glossentry id="gls_ssc"><glossterm>SSC</glossterm> <acronym>SSC</acronym>
	    <glossdef> <para>
		State with Separate Chains. DES state design where data and observing chains are separated.
		    <xref linkend="ds_mae_scc"/>. Ref <xref linkend="gls_scc"/> for another design solution.  </para></glossdef>
	</glossentry>

	<glossentry id="gls_uac"><glossterm>UAC</glossterm> <acronym>UAC</acronym>
	    <glossdef> <para>
		Units for Auxiliary Components
		The approach of agents design where "passive" units are used instead of agnents as
		auxiliary components, ref
		    <xref linkend="ds_uac"/>. Ref <xref linkend="gls_cpa"/>, <xref linkend="gls_pia"/> for other connecting solutions. </para></glossdef>
	</glossentry>

	<glossentry id="gls_umt"><glossterm>UMT</glossterm> <acronym>UMT</acronym>
	    <glossdef> <para>
		Unified Mutation Target.  The approach of specifying target in mutation spec.
			With this approach the target specified with just one mutation attribute, ref
		    <xref linkend="ds_umt"/>.  Ref <xref linkend="gls_cmt"/> for alternative approach.</para></glossdef>
	</glossentry>
    </glossary>

    <sect1 id="ds_itr"><title>Intro</title>
	<sect2 id="ds_itr_sp"><title>The scope of the project</title>
	    <simpara>
		This project is focusing on re-desing of DES framework fap3, ref
		<ulink url="../../../fap3/doc/design/index.html"/> to improve the performance rate and design.
	    </simpara>
	    <simpara>
                The main idea of how to achieve this is to get rid of <xref linkend="gls_irm"/> and instead apply <xref linkend="gls_dri"/> approach.
                    IRM itself being very powerful design approach causes performance degradation in case of system massive re-configuration. Ref
		<ulink url="../../../fap3/doc/design/index.html#ds_dri"/> for initial discussion.
	    </simpara>
            <itemizedlist>
                <listitem>
                    Getting rid of IRM 
                    <xref linkend="ds_nuirm"/>
                </listitem>
                <listitem>
                    Avoid using
                    <xref linkend="gls_irm"/>
                </listitem>
                <listitem>
                    Apply local iface resolution basing on numeric type Id instead of string type Id.
                </listitem>
            </itemizedlist>
        </sect2>
        <sect2 id="ds_itr_dp"><title>Dependent projects</title>
            <sect3 id="ds_itr_dp_fap3"><title>Predesessor, DES framework fap3, ref <ulink url="../../../fap3/doc/design/index.html"/></title>
            </sect3>
        </sect2>
    </sect1>

    <sect1 id="ds_dri"><title>Iface resolution not using IRM - Direct resolution of iface (<xref linkend="gls_dri"/>).</title>
        <sect2><title>Intro</title>
            <simpara>
                Getting rid of IRM means that that we need to replace the "connections" created by IRM (actually the iface resolved via IRM) is
                kind of connection) with connections created via local iface resolution or via some other way. We can use native connections
                representing such connections. Important point is that IRM establishes "connections" on demand. In contrary non-IRM mechanism shall
                create the connections on system construction phase.
            </simpara>
            <simpara>
                With DRI approach local iface resolution + the iface request propagation are used instead of global iface resolution + iface
                request to resolved ifaces.
                With this approach there should be the "chain" if "iface points" thru which the iface request is propagated. This chain can be
                combined with different means: connections, dedicated access methods (like MVert::getExtd(), MSocket::getPin()) etc.
            </simpara>
            <simpara>
                In most cases special connection (binding) can be used to create the chain of iface implementators propagating iface request.
            </simpara>
        </sect2>
        <sect2 id="ds_dri_mcins"><title><xref linkend="gls_dri"/> approach limitations: Multiple-connection inputs aren't supported</title>
            <sect3 ><title>Intro</title>
                <simpara>
                    Ref fap3 ut_des_utl_2.chs - multiple inputs are connected to extender Ext. But with
                    <xref linkend="gls_dri"/> 
                        they are not resolved from dutil.chs InpItr.Itr.InpCnt.
                </simpara>
                <simpara>
                    This limitation is caused by the limitation of local resolution API - MIface::getLif() that returns just one iface.
                </simpara>
                <simpara>
                    The limitation is very serious: many apps use multi-connection inputs, fap3-vis AVR project for instance.
                    In AVR DRP as owner collects data from CRP (owned) via DES context down-to-up components.
                    This is very useful and powerful design approach.
                </simpara>
            </sect3>
            <sect3 id="ds_dri_mcins_s1"><title>Solution#1 Extend MDVarGet iface to get multiple data.</title>
                <simpara>
                    This solution requres minimum changes: new method needs to be implemented only in nodes that support
                    multiple data, transition TrAddVar for instance.
                </simpara>
            </sect3>
            <sect3><title>Status</title>
                <simpara>
                    <xref linkend="ds_dri_mcins_s1"/> applied atm.
                </simpara>
            </sect3>
        </sect2>
        <sect2 id="ds_dri_oto"><title><xref linkend="gls_dri"/> approach limitations: Binding supports one-to-one connection only</title>
            <sect3><title>Intro</title>
                <simpara>
                    Current implementation of DRI supports only one-to-one binding. This for instance cause limitation in sockets connection -
                    it can be one-to-one only.
                </simpara>
                <simpara>This limitation needs to be avoided. We need one-to-many sockets connection. One use-case if AVR VertDrp where
                    the number of edges VertCP can connecto to one vert edgeCp. Ref for instance test ut_avr_vert_drp_2.</simpara>
            </sect3>
            <sect3 id="ds_dri_oto_s1"><title>Solution#1 Enable one-to-many binding, use native CP for binding but not simple ptr. </title>
                <simpara>
                    Ref also <xref linkend="ds_dri_uncp"/>
                </simpara>
            </sect3>
        </sect2>
        <sect2 id="ds_dri_uncp"><title>Binding: using native CP instead of simple ptr.</title>
            <sect3><title>Intro</title>
                <simpara>
                    Currently simple ptr is used for binding. The idea was that binded node is under full control of binding "owner"
                    (that actually gives "provided" iface). So the owner unbinds binded node in cases the binding invalidates. But in some cases 
                    this "control" gets not so simple. The example is removing some pin in socket connected. Socket needs to handle pin removal
                    and unbind pins properly. 
                </simpara>
                <simpara>
                    More robust approach is to use native CP instead of simple ptr. In this case binding invalidation is handling "automatically"
                </simpara>
            </sect3>
        </sect2>
    </sect1>

    <sect1 id="ds_vbcr"><title>Vertex-based connpoint redesign</title>
        <sect2><title>Intro</title>
            <simpara>
                FAP3 using Vertex based connpoint vastly. Almost all connections in systems are Vertex-based. Vertex-based connpoint
                utilized <xref linkend="gls_irm"/>. We are going to get rid of using <xref linkend="gls_irm"/> (ref <xref linkend="ds_dri"/>),
                    so we need to change Vertex-based connpoint design.
            </simpara>
        </sect2>
        <sect2 id="ds_vbcr_omb"><title>Does it make sense to support one-to-many binding?</title>
            <simpara>
                There are at least couple use-cases initicating this feature is useful: Socket one-to-many connections and DES context
                    (ref <xref linkend="ds_dctx"/>
            </simpara>
            <simpara>
                Ref
                <xref linkend="ds_dri_oto"/> for more info.
            </simpara>
        </sect2>
        <sect2 id="ds_vbcr_extd"><title>Extender</title>
            <sect3 id="ds_vbcr_extd_rss"><title>Redesign of initial solution (specialized extender implementing ifaces)</title>
                <sect4><title>Intro</title>
                    <simpara>
                        In the scope of fap5 there was initial solution implemented for extenders. This solution is to 
                        specialize extender for givern ifaced (for instance specific extender for StateInp, StateOutp etc).
                        Extender implements given ifaces and acts as binding point.
                    </simpara>
                    <simpara>
                        There are a lot of cons in that approach: specialization (need to create specific agent for given CP),
                        problem with implementing complex extender, for instance extender of sockets etc.
                    </simpara>
                </sect4>
                <sect4 id="ds_vbcr_extd_rss_ep"><title>Approach: generic extender as just proxy for resolving ifaces and binding points.</title>
                    <simpara>
                        This is very similar to the approach applied in fap3. With this approach extender just helps its pair to extended
                        CP. This "resoution" adds extra operations but is generic.
                    </simpara>
                </sect4>
            </sect3>
        </sect2>
    </sect1>

    <sect1 id="ds_sock"><title>Redesign of Socket</title>
        <sect2 id="ds_sock_pve"><title>Design options: pins via extenders</title>
            <sect3><title>Intro</title>
                <simpara>
                    Initial desing of Socket is based on pins. Pin agent implements prov/req ifaces by itsels so 
                    is able to commutate ifaces requests. Pins are binded mutually. This desing option pros is that
                    it is quite simple because pin is simple node, not composite one. The cons are that pins are binded, but
                    binding is one-to-one connection, so Socket based on pins can establish just one-to-one connection.
                </simpara>
            </sect3>
        </sect2>
        <sect2 id="ds_sock_eos"><title>How to suport extender of socket?</title>
            <sect3><title>Intro</title>
                <simpara>
                    This kind of connpoint is usefull in many cases. Actually it is "must have" to createj the chain of propagation 
                    of sockets.  Looks for instance avr2 EdgeCrpRsSlot::EsNext
                </simpara>
            </sect3>
            <sect3 id="ds_sock_eos_ith"><title>Initial thoughts regarding socket extender design</title>
                <simpara>
                    <xref linkend="gls_dri"/> approach is based on iface requests commutation. It's contrary to
                    <xref linkend="gls_irm"/> that is based on iface resolution.
                        Iface request commutation can be done basing on "internal" connections (using term "binding" for that),
                        connections, and other system topologies elements.
                </simpara>
                <simpara>
                    The "generic" extender approach (ref
                    <xref linkend="ds_vbcr_extd_rss_ep"/>) can be used the similar way as it used for simple connpoint extension.
                        The only socket specific is that routing from the pins of extending socket to the pins of extender internal socket 
                        is relatively expensive (needs to resolve socket pair pins by names).
                        So seems that specialized extender approach needs to be used ATM, ref
                    <xref linkend="ds_sock_eos_sse"/>.
                </simpara>
            </sect3>
            <sect3 id="ds_sock_eos_sse"><title>Specialize socket extender</title>
                <simpara>
                    Lets look at the simple extending
                    <programming>
                        Sock1                   Sock2

                        {A B}---[ :A :B Int{A B}-]---{:A :B}
                        _          |  |     | |
                        _          ---------
                        _             |       |
                        _             ---------


                        {} - socket
                        Int - extender internal CP, socket in our case
                        [] - extender, socket actually
                        A - connpoint
                        :A - CP compatible to A
                    </programming>
                        Within socket extender the internal CP pins shall be connected to extender (actually socket) pins  
                </simpara>
            </sect3>
        </sect2>
        <sect2 id="ds_sock_ses"><title>How to support Socket ebmedded to Socket?</title>
            <sect3><title>Intro</title>
                <simpara>
                    This topology is useful for complex systems, like fap5-vis AVR.
                </simpara>
            </sect3>
            <sect3 id="ds_sock_ses_s1"><title>Solution#1 Bind pins-socket as the regular pins </title>
                <sect4><title>Intro</title>
                    <simpara>
                        In the socket we can distingush two parts: set of pins and "multiplexed" pins.
                        Connecting sockets as verts means that we connect "multiplexed" ("zipped" pins) parts of sockets - this is primary
                        connection established via system mutation.
                        This gives us simple way to connect many pins as if they are just single connpoint.
                        In contrary binding of sockets means connecting sockets pins.
                    </simpara>
                    <simpara>
                        So, in short the rule is: connecting sockets is binding socket pins, binding socket is
                        connecting socket pins.
                    </simpara>
                </sect4>
                <sect4><title>Status</title>
                    <simpara>
                        This solution doesn't work. It is hard to explain the reason of this solution corrupted.
                    </simpara>
                </sect4>
            </sect3>
            <sect3 id="ds_sock_ses_s2"><title>Solution#2 Using extenders as socket pins</title>
                <sect4><title>Intro</title>
                    <simpara>
                        With this solution we have sockets connection operation performing pins connection and 
                        sockets binding operation performing pins binding.
                    </simpara>
                </sect4>
            </sect3>
        </sect2>
    </sect1>

    <sect1 id="ds_hinv"><title>Handling of iface is not valid (proxy not set in proxied iface)</title>
        <sect2><title>Intro</title>
            <simpara> Ref <ulink url="../../../fap3/doc/design/index.html#ds_dri_nic"/> </simpara>
            <simpara>
                <xref linkend="gls_dri"/> assumes that we use iface call propagation instead of ifaces resolution.
                    But with this design we need to invent specific mechanism of handling the case where at some point of
                    iface call propagation chain the chain gets broken (i.e. the next iface is not found).
                    The example is MDVarGet iface. Lets assume that there is the following chain:
                <programlisting>
                    (Extd (Int)-)-(-(Inp)-Add2)
                </programlisting>
                    Add2 trasition will call MDVarGet::VDtGet() method. This method will be propagated till Extd::VDtGet() that will returns  
                    nullptr (DbBase*). Currently transition Add will consider this as error so will return error as result. This is not 
                    correct behaviour. 
            </simpara>
        </sect2>
        <sect2 id="ds_hinv_sls"><title>Solutions</title>
            <simpara>
                We need to indication of iface is not able to serve the request from the client. This is the case where proxied iface is
                requested but the proxy is not set. Such indication can be done via two solutions:
            </simpara>
            <sect3 id="ds_hinv_sls_s1"><title>S#1 Modify iface methos to return indication of method cannot be completed because of iface is not "valid" </title>
            </sect3>
            <sect3><title>S#2 Add to iface base  the method returning indication of iface is not "valid"</title>
            </sect3>
        </sect2>
    </sect1>

    <sect1 id="ds_naom"><title>Redesign of native agents observing mechanism</title>
        <sect2><title>Intro</title>
            <simpara>
                Ref
                <ulink url="../../../fap3/doc/design/index.html#ds_obsi"/> for initial proposal of improvement.
            </simpara>
            <simpara>
                Seems we need observable for particular ifaces, MVert, MSyst etc. because those ifaces
                posess specific events that can be exposed.
                Actually, current MObservable is just MNode observer. It includes vague method onObsChanged()
                that tends to notify about some "any" changes. 
            </simpara>
        </sect2>
        <sect2 ds="ds_naom_rq"><title>Requirements</title>
            <sect3 id="ds_naom_rq_01"><title>RQ_01 Extending the events set</title>
                <simpara>
                    Observing shall allow extending the events set. It means that some new agent
                    that can notify of it's specific event shall do it via observation mechaism.
                </simpara>
            </sect3>
            <sect3 id="ds_naom_rq_02"><title>RQ_02 Oblservable provides events with parameter(s)</title>
                <simpara>
                    Example is the current MObservable method
                    <programlisting>
                        void onObsContentChanged(MObservable* aObl, const MContent* aCont) = 0;
                    </programlisting>
                </simpara>
            </sect3>
            <sect3 id="ds_naom_rq_03"><title>RQ_03 Oblservable provides events subscribtion with parameter(s)</title>
                <simpara>
                    In many cases observer request needs to include some parameters also.
                    The example is ASdc::NodeCreationObserver that aims to detect the given node has been created.
                </simpara>
                <simpara>
                    The implementation of this requirement seems too complex. Also it can be substituted by observer specific
                    procedures, like in ASdc::NodeCreationObserver ASdc::NodeCreationObserver.
                </simpara>
            </sect3>

        </sect2>
        <sect2 id="ds_naom_opt_1"><title>Option_1. Use events implementing MIface</title>
            <sect3><title>Intro</title>
                <simpara>
                    With this option events are just specific ifaces implementation. Since each iface if uniquely identified
                    by its ID the observation mechanism is extandable. I.e. some new agents can provide its specific
                    event.
                </simpara>
                <simpara>
                    There is suboption here - to "bind" events to ifaces - for instance the current events "Owner attached",
                    "Owned attached/detached" etc can be bound to MNode. Look at
                    <xref linkend="ds_naom_opt_3"/>. With this subopt we don't need to have specifc hash ID for event - it can
                        be identified with hash id of binded iface plus simple enum.
                </simpara>
            </sect3>
            <sect3><title>Pros</title>
                <sect4><title>Just one observer iface.</title>
                </sect4>
                <sect4><title>Event as the iface allows to pass events extra info to observer.</title>
                    <simpara>
                        Example is the current MObservable method
                        <programlisting>
                            void onObsContentChanged(MObservable* aObl, const MContent* aCont) = 0;
                        </programlisting>
                    </simpara>
                </sect4>
            </sect3>
        </sect2>
        <sect2 id="ds_naom_opt_2"><title>Option_2. Use specific Observer extension iface.</title>
            <sect3><title>Intro</title>
                <simpara>
                    With this option we extend MObserver iface instead of extending events. We can extend
                    MObserver iface by introducing new agent specific MObserver (e.g MNewAgentObserver) that will expose new agent specific
                    events for observation. Note that these new events don't need to be MIface, they can be just 
                    particular contstants defined.
                </simpara>
                <simpara>
                    New agent "base" MObserver needs to expose MNewAgentObserver via local iface resolution.
                </simpara>
            </sect3>
        </sect2>
        <sect2 id="ds_naom_opt_3"><title>Option_3. Observer of ifaces</title>
            <sect3><title>Intro</title>
                <simpara>
                    We introduce particular observers for given ifaces. In that case we don't need to have unique ID for
                    the event, it is enough to identify events with simple enumeration IDs defined in the scope of the iface
                    (iface has unique ID so events will be identified uniquely).
                    However we need to have specific observer ifaces - MNode observer etc. They need to have ID. So this solution
                    doesn't actually reduce uniquie IDs number.
                </simpara>
                <simpara>
                    The given iface observer has it's owns set of methods. The methods can pass extra parameters, so we
                    don't need to have observers method passing iface based event like in 
                    <xref linkend="ds_naom_opt_1"/>
                </simpara>
                <simpara>
                    As for observer ifaces, this opt is similar to
                    <xref linkend="ds_naom_opt_2"/>
                </simpara>
            </sect3>
            <sect3><title>Pros</title>
                <sect4><title>Observer iface can include notif method with extra parameters.</title>
                </sect4>
            </sect3>
        </sect2>
    </sect1>

    <sect1 id="ds_rdadp"><title>Redesig of DES adapter</title>
        <sect2><title>Intro</title>
            <simpara>FAP3 DES adapter (DAdp) has the following weaknesses: </simpara>
            <itemizedlist>
                <listitem>
                    <glossterm id="ds_rdadp_w1">W#1</glossterm> It uses Link to get the access to managed/observer agent
                    <para>
                        MLink iface and Link impl seem inconsistent. They introduce one-way linkage that is
                        used in DES adapter only. Ref
                        <xref linkend="ds_rdadp_uac"/> for solution.
                    </para>
                </listitem>
            </itemizedlist>
	</sect2>
	<sect2 id="ds_rdadp_uac"><title>Using agent connpoint to avoid using Link for DES adapter.</title>
	    <sect3><title>Intro</title>
		<simpara> This is the solution of the problem <xref linkend="ds_rdadp_w1"/> </simpara>
		<simpara>
		    The idea is to exployt the ifaces MAgent/MAhost to get the access from DES adapter
		    to managed/explored agent (MAG). Let's assume that we will manage/explore only systems, but
		    not nodes etc. This is reasonable because simple agents usually dont include owneds tree.
		    System supports agents mechanism so implements MAhost iface. So we can introduce connpoint that
		    provides MNode and requires iface MAdp that includes the method of getting notification regarding
		    MAG change.
		</simpara>
	    </sect3>
	</sect2>
        <sect2><title>Do we need dedicated iface for resolving supplier and consumer.</title>
            <simpara>
                The alternative would be to exploit consumer/supplier owners (DES) local iface resolution mechamism.
                But this option is not good because local resolution mechanism is used for global resolution.
                The main design change of fap5 is avoiding global iface resolution, ref
                <xref linkend="ds_dri"/>, so, it would be reasonable to have dedicated iface for resolving "distant" iface.
            </simpara>
            <simpara>So, let's keep using dedicated iface for resolving supplier/consumer atm.</simpara>
        </sect2>
    </sect1>

    <sect1 id="ds_owrowd"><title>Adjust Owner-Owned relationship</title>
	<sect2><title>Intro</title>
	    <simpara>
		Currently Owner-Owned relationship isn't seep consistent.
		For instance MOwner contains methods that allows owned (note that owned has access to its owner) manipulating
		of owner, i.e. attachOwned(), getOwned(). This needs to be fixed. 
	    </simpara>
	    <simpara>
		On fap3 these vulnerable methods are missed in MOwner. They were added in the scope of 
		ifaces review and improvement. 
	    </simpara>
	</sect2>
	<sect2><title>Analysis</title>
	    <simpara>
		"Why we need to remove attachOwned() from MOwner? It is clearly Owner functionality." - can ask someone.
		Right. But in our case the iface is just one part of mutual interaction Owner-Owned. And method in the 
		iface shall expose the functionality for pair. In our case MOwner is owner iface for owned. Obviously
		owner shall not offer attachOwned() for owned.
	    </simpara>
	    <simpara>
		So, we can follow the approach where some methods prohibited for MOwner are moved to MOwner backend - MNode.
	    </simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_miuri"><title>Do we need method Uri() in MIface</title>
	<sect2><title>Intro</title>
	    <simpara>
		In cases where agents are object of manipulation (examples are 
		<xref linkend="gls_sdo"/>, <xref linkend="gls_sdc"/>, of distributed systems (ref project fap2-svr for instance)
		    the ifaces are manipulated via its identifiers (UID).  (In case of distributed system there are explicit proxy agents
		    that contains binded agents (or ifaces) UID. Ref
		<ulink url="../../../../fap2-srv/doc/design/index.html#ds_uid"/> regarding UID in distributed system.
	    </simpara>
	    <simpara>
		Consider simple
		<xref linkend="gls_sdo"/> SdoPair. It outputs DGuri. This URI identifies the pair. URI plays UID role here.
		    The problem here that the pair (actually MVert iface) doesn't have method for gerring URI.
		    So the question is if we need to use UID for agent identification? Currently MIface::Uid() is used for 
		    debugging puposes only and cannot be used for real identification - e.g. it is not possible to
		    get agent ref by UID, only URI is used for that. 
	    </simpara>
	    <simpara>
		Seems using UID for real identification requires serious re-design. So at the moment we can just extend MVert
		iface with vertGetUri() method to provide SDO agents with explored agents URI.
	    </simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_dfi"><title>Using "Data fixation in inputs" (DFI) approach</title>
        <sect2><title>Intro</title>
            <simpara>
                With this approach data on update phase is freezed in inputs not in states. So, state contains just single data buffer, not double.
                This data buffer is updated on update phase. On confirm phase the data from states latch in inputs.
            </simpara>
            <simpara>
                This design already discussed in the context of SDC design, ref 
                <ulink url="../../../fap3/doc/design/index.html#ds_dee_ssi"/>
                    Note that "double buffering" is actually wrong design, we dont need "double" buffering, just single but on update phase to
                    freeze the input. We prepared "double buffering" input with DesEIbt but it isn't used. SDC uses "sigle" buffering with SdcIap.
            </simpara>
            <simpara>
                Data fixation in inputs approach is suitable for the cases where state is not a simple data. Example of this case is SDC where "state" is
                the whole managed system. UOC state don't need to have coupled data for update/confirm, single data is enough.
                Update on update phase (UOU) is suitable for the cases where state is simple data, this is the common condition for
                many "tipical" DES. This approach allows to make DES more optimal for single state output can be used by more that one inputs.
            </simpara>
        </sect2>
    </sect1>

    <sect1 id="ds_samn"><title>System agent mechanism. Do we need it?</title>
        <sect2><title>Intro</title>
            <sect3><title>Useful mechanism</title>
                <simpara>
                    This mechanism is activelly used in fap3. System can embed specific agent that implements MAgent iface. The agent has an access to 
                    "host" owneds. Also system routes IFR to agents so agents can "represent" system specific native behaviour i.e. support native
                    specialization. In fap5 there was initially idea to get rid of this mechanism to simplify systems and because fap5 doesn't support IRM.
                    But seems the mechanism is really usefull in some use-cases.
                </simpara>
            </sect3>
            <sect3><title>One use-case: fap5-vis widget system</title>
                <simpara>
                    One use-case is fap5-vis widget system. On one hand there is Widget DES iface (mostly specified via single connpoint Cp : WidgetCp).
                    On another hand widget is specialized via native behaviour specified by MSceneElem iface.
                    In fap3-vis the solution of specialization was to use "base" Widget with Cp and states (allocation, font etc) and specialized
                    agent that specifically implement MSceneElem. What design can we have for Widget specialization with no usage agent approach?
                </simpara>
            </sect3>
            <sect3><title>Another use-case is avr2: for instance EdgeCrpHsSlot</title>
                <simpara>
                    Another use-case is avr2: for instance EdgeCrpHsSlot inherits from  ContainerMod.ColumnItemSlot (Syst actually) but requires to
                    be DES. So in just includes ADes agent.
                </simpara>
            </sect3>
        </sect2>
        <sect2><title>Option#1: keep agents</title>
            <sect3><title>Intro</title>
                <simpara>
                    We can keep agent mechanism to support convenient system customization with extra native behaviour.
                    The problem here in case of fap5-vis widget is that widget agent needs to have access to widget states (allocation, font path etc.).
                    How to get data from them? With agent mechanism it is not a problem because agent has an access to agent host system MNode iface.
                    (this approach is used in fap3).
                </simpara>
                <simpara>
                    Another option is to embed input+inp_observer for each state. Each Input observer will get data on notification of
                    input changed and cache the data. Note the fap3-vis widget already uses this approach partially (ref mIbText as DesEIbs and mOstRqsW as
                    DesEOsts).  This will optimize the process of preparing data for rendering - fap3-vis widget
                    gets data each rendering even the data is not changed.
                </simpara>
                <simpara>
                    This should work but another problem with such specialization design is that we need to connect widget agent inputs 
                    to widget states. fap3-vis widget already does it via customizing widget conn mutations. Potentially we can use SDC for that. 
                </simpara>
            </sect3>
        </sect2>
        <sect2><title>Option#2: Just use native owned explicitly connected to base widget states.</title>
            <sect3><title>Intro</title>
                <simpara>
                    As discussed in option#1 we actually don't need to have direct access from native customizing node to widget states - we can
                    use explicit connections instead. However the question still remains of how the node can expose MScelem iface? This can be
                    done with native connection. For this approach base widget needs to be specific but not just DES. The specifics is that it
                    shall implement both MScelem and MScelemOwner and have native connpoint to establish connection MScelemOwner-MScelem to the
                    widget customizing node.
                </simpara>

            </sect3>
        </sect2>
        <sect2><title>Status</title>
            <sect3><title>20250521 Keep system agents mechanism.</title>
            </sect3>
        </sect2>
    </sect1>

    <sect1 id="ds_usaid"><title>How to design update specific native agents internal data</title>
        <sect2><title>Intro</title>
            <simpara>
                Sometimes we need to design and use specific agents but not just base provided. The example is fap5-vis widgets.
                Such agents posses some system resources (i.e. internal data). For widget it is font class instance for example.
                This data often depends on system data (widget DES environment) data in our example. The question is how to desing
                the update of internal data when it's dependentcies (inputs) changed.
            </simpara>
            <simpara>
                Note that we need to have normal DES cycle implemented here: data needs to bu updated on DES update phase to be
                consistent. The idea to update font direcly in MDesInpObserver::onInpUpdated() is wrong. This idea could lead to 
                uncertanty, the relust will depends on order of change FontPath and FontSize. So anycase we need that widget be DES.
            </simpara>
            <simpara>There are some approache here:</simpara>
        </sect2>
        <sect2 id="ds_usaid_staid"><title>Approach#1: Specific transition with the access to internal data.</title>
            <simpara>
                Widget is DES. Widget includes state StFont, input InpFont and transition TrFont with connections InpFont - TrFont - StFont.
                TrFont has an access to the widget's native font object and updates it on DES update phase.
            </simpara>
        </sect2>
        <sect2 id="ds_usaid_sdpo"><title>Approach#2: State of specific data "Pointer to object" </title>
            <sect3><title>Intro</title>
                <simpara>
                    Widget is DES. Widget includes state StFont, input InpFont and transition TrFont with connections InpFont - TrFont - StFont. 
                    StFont is of specific data "Pointer to FTPixmapFont font object".
                    TrFont creates new proper FTPixmapFont on updata and gives it to StFont. StFont gets new data from TrFont and sets update data.
                    This specific data "Pointer to object" deletes current object if any and sets new pointer as mData.
                </simpara>
            </sect3>
            <sect3><title>Problem: how to create pointer to specific object type?</title>
                <simpara>
                    For SomeType pointer we need to create std::unique_ptr&lt;SomeType&gt;. To do it we need pointer of object types factory that
                    creates the data of given type. Also we need object type signature that will be a part of data signature, "SDO FTPIXMAPFONT" where
                    SDO (Specific Data Object) is the signature main part of data and FTPIXMAPFONT is the sub-signature designating the object type.
                </simpara>
                <simpara>This complicates the solution.</simpara>
            </sect3>
        </sect2>
    </sect1>

    <sect1><title>Iface that exposes its own connpoint - is it ok?</title>
        <sect2><title>Intro</title>
            <simpara>
                The local connections replace IRM according to fap4 design principle. Connection initiator gets connpoint from potential pair and
                if cp is obtained then establishes the connection. To get connpont the initiator first gets proper iface from the potential pair and
                then gets connpoint via this iface. For instance to establish owning-owner connection the onwer (initiator) gets first MOwning iface and
                the CP using MOwning::ownedCp(), ref Node::attachOwned().
                This procedure seems a bit overcomplicated. Wouldn't it be simpler to resolve CP directly?
            </simpara>
        </sect2>
    </sect1>

    <sect1 id="ds_sdc"><title>SDC improvement and bugfix</title>
    </sect1>

    <sect1 id="ds_prfm"><title>Performance measuring</title>
        <sect2><title>Ut_cntr::testDCntr6</title>
            <simpara>fap3</simpara>
            <programlisting>
                Main thread clock, sec: IFC_LNCH_RUN    3.472145
                Monotonic clock,sec: 13.6
                top %CPU : 20
            </programlisting>
            <simpara>fap5</simpara>
            <programlisting>
                Main thread clock, sec: IFC_LNCH_RUN    0.513847
                Monotonic clock, sec: 0.87 
                top %CPU : 100
            </programlisting>
            <simpara>Why CPU load differs significantly? </simpara>
        </sect2>
    </sect1>

    <sect1 id="ds_desas"><title><xref linkend="gls_desas"/> improvement and bugfix</title>
        <sect2><title>Deny Solution_2</title>
            <simpara>
                Ref comment
                <ulink url="../../../fap3/doc/design/index.html#ds_desas_nio_ric_swr"/>
            </simpara>
        </sect2>
        <sect2><title>History</title>
            <sect3><title>20250723 In the scope of FAP5: Discarded Solution_2</title>
                Discarded Solution_2 because of
                <xref linkend="ds_desas_nio_ric_swr"/>
                    Applied Solution 1 with some modifications.
            </sect3>
        </sect2>
    </sect1>

    <sect1 id="ds_dctx"><title>DES context (<xref linkend="gls_dctx"/>) improvement</title>
        <sect2><title>Intro</title>
            <simpara>
                Current DES Ctx implementation uses IFR so we need to re-implement it. Same time there are some design points and possible
                improvements.
            </simpara>
            <simpara>
                Ref
                <ulink url="../../../fap3/doc/design/index.html#ds_dct"/> for fap3 DES context materials.
            </simpara>
        </sect2>
        <sect2 id="ds_dctx_ia"><title>Intial analysis</title>
            <sect3 id="ds_dctx_ia_wid"><title>Why ctx supplier and consumer are implemented as DES?</title>
                <simpara> Current implementation uses first DES tick for initialization.  </simpara>
                <simpara>
                    Alternative way is to move the initializatin to system creation phase.
                    But with this approach the owner needs to handle ctx element addintion - just handling the addition of spl/csm itself is
                    not always enough because "onwed added" event happens before owned mutation is completed.
                </simpara>
                <simpara>
                    On one hand init on first tick looks reasonable: if allows to start initialization after spl/csm full mutations.
                    On anonter hand it looks not common.
                </simpara>
            </sect3>
            <sect3><title> Do we need MDesCtxCsm::onCtxAdded(), MDesCtxCsm::onCtxRemoved() ? They aren't used atm.  </title>
                <simpara>Consumer and Supplier can use MObserver/MObservable ifaces of each other to observe the changes.</simpara>
            </sect3>
            <sect3><title> Why we apply context mechanism in DES only? The mechanism is universal to "bind" upper and lower layers of system hierarchy.</title>
            </sect3>
            <sect3><title> Context is very similar to socket, can we apply socket design to context?  </title>
                <sect4><title>Intial thoughts</title>
                    <simpara>
                        The similarity also is in fact that context supplier and consumer gets "connected" via registration.
                    </simpara>
                    <simpara>But actualy the curent context scheme is more complicated than just connection: if current supplier doesn't have proper context item 
                        from consumer then supplier propagates binding request to the owner (but consumer remains "connected" to one supplier, seems as fault).</simpara>
                    <simpara>What is the reason of such design, what are use-cases? BTW socket based design was initial consideration in fap3 DES Context.</simpara>
                    <simpara>
                        These approaches (Dedicates spl/csm vs socket) have its own ideas. Dedicates spl/csm is just container that helps binding context.
                        Primary point here is spl/ctx
                        element that provides the context data but not the container itself. For socket based context the spl/ctx is connpoint.
                    </simpara>
                    <simpara>Needs to attempt to implement context as socket but with some updates: support one-to-many socket (one-to-one is supported atm),
                        binding update on addition/removal pins.</simpara>
                    <simpara>
                        In that case we will still need supplier/consumer interfaces to support contexts resolution and binding.
                    </simpara>
                </sect4>
                <sect4><title>Socket based ctx. Problem: binding on creation phase will not work because of socket incompatibility.</title>
                    <simpara>
                        The often case is that context is created following the mutations of adding socket pins. If we try to bind contexts
                        on "Owned added" event than the context (socket) is not mutated yet so will failed on connection attempt.
                    </simpara>
                    <simpara>
                        This is the weakness of Socket-based approach. In "classic" container-based approach we don't check csm-spl compatibility 
                        basing on context elements but just use ifaces to check they are complimentary.
                    </simpara>
                </sect4>
                <sect4><title>Socket based ctx. Why not to use it.</title>
                    <simpara>
                        Valid use-case is adding/removing context elements. In case of socket it needs quite complicated implementation because
                        adding socket pin makes socket incompatible with pair.
                    </simpara>
                </sect4>
            </sect3>
            <sect3><title>Do we really needs special mechanism for auto-binding?</title>
                <simpara>Why don't use explicit connection when creating subsystem? It will cost just one "conn" mutation.</simpara>
                <simpara>
                    Auto-connect mechanism seems convenient when creating big systems, but this needs to be thinked over.
                    Int that case maybe it make sense to have generic autoconnect mechanism with the proper interfaces for resolution.
                </simpara>
            </sect3>
            <sect3><title>Initially redesigned as non-DES - it is not working</title>
                <simpara>
                    Tried to implement ctx just as vertex but not DES. But it doesn't work because of context/supplier binding
                    happens on mutation phase (particularly when consumer/supplier added to owner). On this phase the consumer owner
                    is not attached to the system tree yet, so find of ctx pair is not possible. This is the answer on the question
                    <xref linkend="ds_dctx_ia_wid"/>
                </simpara>
                <simpara>
                    Needs to return to initial DES based design or find other design options.
                </simpara>
            </sect3>
        </sect2>
        <sect2 id="ds_dctx_v2"><title>DES Ctx ver 2: socket based</title>
        </sect2>
    </sect1>

    <sect1 id="ds_opt"><title>Optimization</title>
        <sect2 id="ds_opt_udth"><title>Use data type ID as hash</title>
            <simpara>
                Do same opt as for ifaces id was done. Avoid using strings comparition.
            </simpara>
        </sect2>
    </sect1>

</article>

